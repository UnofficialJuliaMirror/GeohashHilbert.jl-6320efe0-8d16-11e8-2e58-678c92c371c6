<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GeohashHilbert.jl Documentation · GeohashHilbert documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>GeohashHilbert documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>GeohashHilbert.jl Documentation</a><ul class="internal"><li><a class="toctext" href="#Geohash-Hilbert-basics-1">Geohash Hilbert basics</a></li><li><a class="toctext" href="#Encoding/decoding-1">Encoding/decoding</a></li><li><a class="toctext" href="#Other-features-1">Other features</a></li><li><a class="toctext" href="#Python-geohash-hilbert-interoperability-1">Python <code>geohash-hilbert</code> interoperability</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>GeohashHilbert.jl Documentation</a></li></ul><a class="edit-page" href="https://github.com/zobainc/GeohashHilbert.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>GeohashHilbert.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="GeohashHilbert.jl-Documentation-1" href="#GeohashHilbert.jl-Documentation-1">GeohashHilbert.jl Documentation</a></h1><p>GeohashHilbert.jl provides a pure-Julia implementation of a Hilbert-curve-based <a href="https://en.wikipedia.org/wiki/Discrete_global_grid#Geocodind_variants">discrete global grid</a>, often referred to as a geohash system. GeohashHilbert.jl aims to be interoperable with the Python package <a href="https://github.com/tammoippen/geohash-hilbert">geohash-hilbert</a> in the sense that the packages agree on the encoding of each longitude-latitude pair.</p><ul><li><a href="#GeohashHilbert.jl-Documentation-1">GeohashHilbert.jl Documentation</a></li><ul><li><a href="#Geohash-Hilbert-basics-1">Geohash Hilbert basics</a></li><li><a href="#Encoding/decoding-1">Encoding/decoding</a></li><li><a href="#Other-features-1">Other features</a></li><li><a href="#Python-geohash-hilbert-interoperability-1">Python <code>geohash-hilbert</code> interoperability</a></li></ul></ul><h2><a class="nav-anchor" id="Geohash-Hilbert-basics-1" href="#Geohash-Hilbert-basics-1">Geohash Hilbert basics</a></h2><p>Geohash systems (or discrete global grid systems, but geohash is shorter and sounds cooler) partition the surface of the Earth into contiguous cells and associate a hash with each cell. There are lots of reasons you might want to do this; the two most common are:</p><ol><li>Hashes provide a way to compactly represent approximate locations.</li><li>It&#39;s convenient to group locations by the cell they&#39;re in, and computing the hash for  a given location is an easy way to look up which cell that location is in.</li></ol><p>The primary purposes of GeohashHilbert.jl are to <a href="#GeohashHilbert.encode"><code>encode</code></a> locations and <a href="#GeohashHilbert.decode"><code>decode</code></a> hashes. Encoding a location means computing the hash associated with the region of the Earth&#39;s surface that location is in. Decoding a hash means computing the locations that are encoded as that hash. Typically, the surface of the Earth can be partitioned with varying granularity. Granular partitions mean that each cell of the partition is small and a corresponding hash provides a lot of location information. Coarse partitions mean that each cell of the partition is large, and hashes provide little location information. Accordingly, hashes for granular partitions are longer than hashes for coarse partitions. An example of a maximally-coarse partition would be simply encoding the hemisphere of a longitude-latitude pair: <code>0</code> for northern hemisphere and <code>1</code> for the southern hemisphere. Notice that the hash is short (just a single bit), but if I tell you that a location has a hash of, say, <code>0</code>, all you know is that the location is in the northern hemisphere.</p><p>To encode a longitude-latitude pair as a hash string with GeohashHilbert.jl, you need to specify a <code>precision</code>, which is the number of characters in the resulting hash, and a <code>bits_per_char</code>, which unsurprisingly is how many bits of information each character in the hash encodes. Currently, we support <code>bits_per_char</code> of 2, 4, or 6. The bits of information in the resulting hash will then be <code>precision * bits_per_char</code>. When decoding a hash, the <code>precision</code> is inferred from the hash length and then does not need to be specified.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Do not strip leading zeros from hashes, or else the inferred <code>precision</code> will be incorrect. The common cause of dropping leading zeros is writing hashes (which are strings) to a text format like CSV; when the written file is read, they may be parsed as integers which causes leading zeros to be ignored.</p></div></div><p>The character set of your hash depends on the <code>bits_per_char</code> chosen:</p><ul><li><code>bits_per_char = 2</code> : <code>0123</code></li><li><code>bits_per_char = 4</code> : <code>0123456789abcdef</code></li><li><code>bits_per_char = 6</code> : <code>0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz</code></li></ul><p>One nice property of the GeohashHilbert hashing algorithm is that hash cells at different precision levels nest perfectly. In particular, each hash cell is contained in the lower-precision hash cells corresponding to its leading bits. For example, suppose you see the precision-4 hash <code>3032</code> (<code>bits_per_char = 2</code>). Then you know:</p><ul><li>The precision-4 cell corresponding to hash <code>3032</code> is contained within the precision-3 cell   <code>303</code>.</li><li>There are exactly 4 precision-5 cells contained in cell <code>3032</code>; they are <code>30320</code>, <code>30321</code>,   <code>30322</code>, <code>30323</code>.</li></ul><h3><a class="nav-anchor" id="Implementation-details-1" href="#Implementation-details-1">Implementation details</a></h3><p>This section provides optional brief details on how the GeohashHilbert.jl hashing algorithm encodes locations; you don&#39;t need to understand this section to use GeohashHilbert.jl.</p><p>Locations on the Earth are represented by a longitude-latitude pair. GeohashHilbert.jl implicitly &quot;unwraps&quot; the Earth into a Cartesian longitude-latitude plane. Since the earth is not a cylinder, this introduces some geometric distortion, especially near the poles. (For example, all points with latitude 90 degrees are the north pole, but GeohashHilbert.jl treats <code>(47, 90)</code> and <code>(-47, 90)</code> as different points.)</p><p>A hash will contain <code>k = precision * bits_per_char</code> bits of information. Half of these bits are used to represent the longitude, and half are used to represent the latitude, as follows. The longitude-latitude plane is divided into a <code>n</code> by <code>n</code> grid where <code>n = 2^(k / 2)</code>. The input longitude-latitude pair is contained in exactly one cell of this <code>n</code> by <code>n</code> grid.</p><p>The cells of the <code>n</code> by <code>n</code> grid are then ordered according to a <code>k/2</code>-th order <a href="https://en.wikipedia.org/wiki/Hilbert_curve">Hilbert curve</a> which passes through each grid cell exactly once. Therefore, each grid cell is associated with an integer in <code>[0, n^2)</code>. Namely, the <code>i</code>-th cell along the Hilbert curve is assigned integer <code>i-1</code>. So, the input longitude-latitude pair is associated with the integer of the grid cell it&#39;s contained in. Finally, the integer is mapped to a hash string by simply encoding the integer in base 4, base 16, or base 64.</p><p>Decoding a hash reverses the process: a hash string is parsed as an integer, the integer is mapped (according to the Hilbert curve) to a grid cell, and the grid cell is mapped to the latitude-longitude point at its center.</p><h2><a class="nav-anchor" id="Encoding/decoding-1" href="#Encoding/decoding-1">Encoding/decoding</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeohashHilbert.encode" href="#GeohashHilbert.encode"><code>GeohashHilbert.encode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">encode(lon, lat, precision, bits_per_char = 2)</code></pre><p>Encode a longitude-latitude pair as a geohash string. The length of the resulting geohash is <code>precision</code>, so higher <code>precision</code> gives a finer grained encoding. Return the geohash string.</p><p><strong>Arguments</strong></p><ul><li><code>lon::Real</code>: longitude in degrees of point to encode. Must be in [-180,180].</li><li><code>lat::Real</code>: latitude in degrees of point to encode. Must be in [-90,90].</li><li><code>precision::Integer</code>: precision of returned geohash. Must be positive.</li><li><code>bits_per_char ∈ [2,4,6]</code>: how many bits of information each character encodes.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>To avoid overflow in machine arithmetic, <code>precision * bits_per_char</code> must be &lt;= 62. This still allows meter-level granularity. If your use case requires sub-meter granularity, you may wish to reconsider using longitude-latitude coordinates.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/zobainc/GeohashHilbert.jl/blob/b25799f42782bf0aed53df4ae54d8f35f8086e09/src/GeohashHilbert.jl#L99-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeohashHilbert.decode" href="#GeohashHilbert.decode"><code>GeohashHilbert.decode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">decode(geohash, bits_per_char = 2)</code></pre><p>Given a <code>geohash</code> string at a specified <code>bits_per_char</code>, return the coordinates of the corresponding geohash cell&#39;s center as a tuple <code>(lon, lat)</code>.</p><p>See also: <a href="#GeohashHilbert.decode_exactly"><code>decode_exactly</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zobainc/GeohashHilbert.jl/blob/b25799f42782bf0aed53df4ae54d8f35f8086e09/src/GeohashHilbert.jl#L265-L272">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeohashHilbert.decode_exactly" href="#GeohashHilbert.decode_exactly"><code>GeohashHilbert.decode_exactly</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">decode_exactly(geohash, bits_per_char)</code></pre><p>Given a <code>geohash</code> string at a specified <code>bits_per_char</code>, return the coordinates of the corresponding geohash cell&#39;s center and the error margins as a tuple <code>(lon, lat, lon_err, lat_err)</code>. That is, each point in the corresponding cell has longitude within <code>lon</code> ± <code>lon_err</code> and likewise for latitude.</p><p>See also: <a href="#GeohashHilbert.rectangle"><code>rectangle</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zobainc/GeohashHilbert.jl/blob/b25799f42782bf0aed53df4ae54d8f35f8086e09/src/GeohashHilbert.jl#L281-L290">source</a></section><h2><a class="nav-anchor" id="Other-features-1" href="#Other-features-1">Other features</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeohashHilbert.neighbours" href="#GeohashHilbert.neighbours"><code>GeohashHilbert.neighbours</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">neighbours(geohash, bits_per_char = 2)</code></pre><p>Compute the geohashes of the cells neighboring the specified geohash cell. Return a dictionary keyed by &quot;north&quot;, &quot;north-east&quot;, &quot;east&quot;, etc. and with values the geohash string of the corresponding adjacent cell at the same precision and bits per character. Note that cells near the poles will have only five neighbors.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zobainc/GeohashHilbert.jl/blob/b25799f42782bf0aed53df4ae54d8f35f8086e09/src/GeohashHilbert.jl#L306-L313">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="GeohashHilbert.rectangle" href="#GeohashHilbert.rectangle"><code>GeohashHilbert.rectangle</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rectangle(geohash, bits_per_char = 2)</code></pre><p>Return a GeoJSON Dict that encodes as a Feature the rectangle associated with a given <code>geohash</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zobainc/GeohashHilbert.jl/blob/b25799f42782bf0aed53df4ae54d8f35f8086e09/src/GeohashHilbert.jl#L352-L357">source</a></section><h2><a class="nav-anchor" id="Python-geohash-hilbert-interoperability-1" href="#Python-geohash-hilbert-interoperability-1">Python <code>geohash-hilbert</code> interoperability</a></h2><p>First and foremost, GeohashHilbert.jl and geohash-hilbert should agree on the encoding of any longitude-latitude pair at any precision and likewise agree on the decoding of any geohash string. If the packages don&#39;t agree, that&#39;s a bug, and you should feel encouraged to file an issue. As a result of this consistency, it should be safe to &quot;mix&quot; geohashes between packages. For example, you could safely encode the geohashes of points using GeohashHilbert.jl, write the hashes to a CSV file, and decode those geohashes using geohash-hilbert.</p><p>We&#39;ve also tried to match the Python package&#39;s style and function names (e.g. <code>neighbours</code> instead of <code>neighbors</code>). The internal logic, however, is quite different and more Julian. In particular GeohashHilbert.jl uses lightweight Julia types rather than bit fiddling for its core calculations.</p><footer><hr/></footer></article></body></html>
